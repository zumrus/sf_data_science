# Проект 0. Угадай число

## Оглавление  
[1. Описание проекта](https://github.com/zumrus/sf_data_science/tree/main/project_0#Описание-проекта)  
[2. Какой кейс решаем?](https://github.com/zumrus/sf_data_science/tree/main/project_0#Какой-кейс-решаем)  
[3. Краткая информация о данных](https://github.com/zumrus/sf_data_science/tree/main/project_0#Краткая-информация-о-данных)  
[4. Этапы работы над проектом](https://github.com/zumrus/sf_data_science/tree/main/project_0#Этапы-работы-над-проектом)  
[5. Результат](https://github.com/zumrus/sf_data_science/tree/main/project_0#Результат)    
[6. Выводы](https://github.com/zumrus/sf_data_science/tree/main/project_0#Выводы) 

### Описание проекта    
Угадать загаданное компьютером число за минимальное число попыток. Применяем три разных метода. Первый подход (random_predict) основан на случайном угадывании, второй (game_core_v2) - на пошаговом приближении к загадонному числу, третий (game_core_v3) - на методе бисекции.

:arrow_up:[к оглавлению](https://github.com/zumrus/sf_data_science/tree/main/project_0#Оглавление)


### Какой кейс решаем?    
Нужно написать программу, которая угадывает число за минимальное число попыток

**Условия соревнования:**  
- Компьютер загадывает целое число от 0 до 100, и нам его нужно угадать. Под «угадать», подразумевается «написать программу, которая угадывает число».
- Алгоритм учитывает информацию о том, больше ли случайное число или меньше нужного нам.
- Необходимо добиться того, чтобы программа угадывала число меньше, чем за 20 попыток.

**Метрика качества**     
Результаты оцениваются по среднему количеству попыток при 1000 повторений. Введена также дополнительная метрика, которая вычисляет математическое ожидание числа попыток. 

Мне показалось странным, что для метрики скорости алгоритма используется радномный прогон через большой массив случайных чисел, в то время как ее асимптотическое значение вычисляется очень легко через матожидание. Поэтому я написал дополнительную функцию, которая делает это. В ней функции скармливаются все значения от 1 до 100 и вычисляется средне арифметическое.

Оценки, сделанные первой метрикой, должны стремиться к оценкам, сделанным второй, в пределе очень больших числах повторений, но при этом вторая считается существенно быстрее, чем первая

**Что практикуем**     
- Учимся писать хороший код на Python
- Учимся работать с IDE
- Учимся работать с GitHub


### Краткая информация о данных
Финальный для задания код содержится в файле [game_v3.py](https://github.com/zumrus/sf_data_science/blob/main/project_0/game_v3.py)
  
:arrow_up:[к оглавлению](https://github.com/zumrus/sf_data_science/tree/main/project_0#Оглавление)


### Этапы работы над проектом  
....

:arrow_up:[к оглавлению](https://github.com/zumrus/sf_data_science/tree/main/project_0#Оглавление)


### Результаты:  
Только третий метод удовлетворяет всем условиям соревнования. Об этом свидетельствуют обе метрики.

:arrow_up:[к оглавлению](https://github.com/zumrus/sf_data_science/tree/main/project_0#Оглавление)


### Выводы:  
На данный момент метод бисекции кажется наибыстрейшим из всех возможных методов решения задачи об угадывании. Обе метрики показывают примерно одинаковые значения, однако вторая - более точная, но при этом более быстрая. Вместе с тем, ее использование основано на малости диапазона поиска (от 1 до 100). При существенно большем диапазоне она может уступать по скорости вычисления первой метрике, предложенной авторами курса. 

:arrow_up:[к оглавлению](https://github.com/zumrus/sf_data_science/tree/main/project_0#Оглавление)

